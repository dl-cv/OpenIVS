### 总览

输入：C:\Users\Administrator\Desktop\dlcv_test\backend\multi_tasks\NewModules
输出：C:\Users\Administrator\Desktop\OpenIVS\DlcvModules

- **总类数**: 26（按文件分布见下）
- **统一 I/O 约定**: 所有模块类的 `process(image_list, result_list) -> (image_list, result_list)`；输入输出为空时用空列表；模块内部用 `ModuleImage + TransformationState` 在图像裁剪/仿射链路中保存“从原图到当前图”的变换关系；结果统一为 `type=="local"` 的条目，含 `sample_results` 和定位信息 `index/origin_index/transform`。
- **执行框架**: `GraphExecutor` 读取前端 JSON 图（nodes/links），经 `ModuleRegistry` 实例化各节点类型（由 `@register_module` 装饰器注册），根据端口命名/索引将多路输入路由为 `(image_list, result_list)` 成对通道，执行每个节点的 `process`，并将模块的 `extra_outputs`（若有）按约定透出为附加输出对。

### 文件与类清单（每个类/函数/参数）
按文件列出对外可见的类与主要函数签名（省略内部临时/嵌套函数）。

- `backend/multi_tasks/NewModules/base_module.py`（6 类）
  - `class ModuleRegistry`
    - `register(module_type: str, module_cls: Type[BaseModule]) -> None`
    - `get(module_type: str) -> Optional[Type[BaseModule]]`
  - `def register_module(module_type: str) -> (cls -> cls)`
  - `class ExecutionContext`
    - `__init__(**kwargs: Any)`
    - `get(key: str, default: Any=None) -> Any`
    - `set(key: str, value: Any) -> None`
  - `def normalize_path_string(path: Optional[str]) -> Optional[str]`
  - `class BaseModule`
    - `__init__(node_id: int, title: Optional[str]=None, properties: Optional[Dict]=None, context: Optional[ExecutionContext]=None)`
    - `process(image_list: Optional[List[Any]]=None, result_list: Optional[List[Dict]]=None) -> (List[Any], List[Dict])`
    - `@staticmethod _ensure_list(value: Optional[Any]) -> List[Any>`
  - `class BaseInputModule(BaseModule)`
    - `generate() -> (List[Any], List[Dict])`
    - `process(image_list: Optional[List[Any]]=None, result_list: Optional[List[Dict]]=None) -> (List[Any], List[Dict])`
  - `class TransformationState`
    - `__init__(original_width: int, original_height: int, crop_box: Optional[Tuple[int,int,int,int]]=None, affine_matrix: Optional[np.ndarray]=None, output_size: Optional[Tuple[int,int]]=None)`
    - `@staticmethod _as_3x3(matrix_2x3: np.ndarray) -> np.ndarray`
    - `@staticmethod _to_2x3(matrix_3x3: np.ndarray) -> np.ndarray`
    - `@staticmethod _crop_mat_3x3(x: float, y: float) -> np.ndarray`
    - `@staticmethod _inv_2x3(matrix_2x3: np.ndarray) -> np.ndarray`
    - `clone() -> TransformationState`
    - `to_dict() -> Dict[str, Any]`
    - `@staticmethod from_dict(data: Dict[str, Any]) -> TransformationState`
    - `apply_to_image(original_image: np.ndarray) -> np.ndarray`
    - `derive_child(current_to_new_2x3: np.ndarray, new_width: int, new_height: int) -> TransformationState`
  - `class ModuleImage`
    - `__init__(image_numpy: Optional[np.ndarray], ori_image: np.ndarray, transformation_state: TransformationState, original_index: int=0)`
    - `get_img() -> np.ndarray`
    - `to_meta() -> Dict[str, Any]`

- `backend/multi_tasks/NewModules/inputs.py`（2 类）
  - `class InputImage(BaseInputModule)`（module_type: `"input/image"`, 输出端口含 `filename` 字符串）
    - `generate() -> (List[Any], List[Dict])`
  - `class InputFrontendImage(BaseInputModule)`（module_type: `"input/frontend_image"`)
    - `_resolve_path() -> Optional[str]`
    - `generate() -> (List[Any], List[Dict])`

- `backend/multi_tasks/NewModules/features.py`（3 类）
  - `class ImageGeneration(BaseModule)`（"features/image_generation"）
    - `process(image_list=None, result_list=None) -> (List[Any], List[Dict])`
      - 依据 `result_list` 的检测框对 `image_list` 裁剪，支持轴对齐与旋转框，输出子图为 `ModuleImage`，继承并推导 `TransformationState`。
  - `class MergeResults(BaseModule)`（"features/merge_results"）
    - `process(image_list=None, result_list=None) -> (List[Any], List[Dict])`
      - 合并多路图像与结果，按 `transform/index/origin_index` 对齐；可选图像与结果去重；每张图输出一个 `local` 条目。
  - `class ResultFilter(BaseModule)`（"features/result_filter"）
    - `@staticmethod _serialize_transform(transform: Optional[Dict]) -> Optional[str]`
    - `process(image_list=None, result_list=None) -> (List[Any], List[Dict])`
      - 按 `categories` 将结果与图像分流为两路；第二路通过 `extra_outputs` 暴露为 `image_list_1/result_list_1`。

- `backend/multi_tasks/NewModules/sliding_window.py`（1 类）
  - `class SlidingWindow(BaseModule)`（"features/sliding_window"）
    - `@staticmethod _translation_mat(dx: float, dy: float) -> np.ndarray`
    - `process(image_list=None, result_list=None) -> (List[Any], List[Dict])`
      - 生成滑窗 `ModuleImage` 子图，写入 `sliding_meta`（网格/窗口尺寸/切片索引）。

- `backend/multi_tasks/NewModules/sliding_merge.py`（1 类）
  - `class SlidingMergeResults(BaseModule)`（"features/sliding_merge"）
    - `@staticmethod _serialize_transform(transform) -> Optional[str]`
    - `@staticmethod _build_T_c2o(state: TransformationState) -> np.ndarray`
    - `@staticmethod _transform_points(T: np.ndarray, pts: np.ndarray) -> np.ndarray`
    - `@staticmethod _poly_iou(poly1: np.ndarray, poly2: np.ndarray) -> float`
    - `@staticmethod _poly_aabb(poly: np.ndarray) -> List[float]`
    - `@staticmethod _poly_min_area_rect(poly: np.ndarray) -> List[float]`
    - `@staticmethod _rbox_local_to_global(rbox_local: Any, wrap: ModuleImage) -> Optional[List[float]]`
    - `@staticmethod _poly_from_bbox_global(bbox: Any) -> Optional[np.ndarray]`
    - `@staticmethod _same_category(a: Dict, b: Dict) -> bool`
    - `process(image_list=None, result_list=None) -> (List[Any], List[Dict])`
      - 将局部结果映射回原图坐标，依据 `task_type/iou_threshold` 执行相邻窗去重/合并（旋转框保角度、分割并集、检测并集），每个原图输出一个 `local` 条目（`transform=None`）与原图 `ModuleImage`。

- `backend/multi_tasks/NewModules/models.py`（6 类 + 4 模块函数）
  - 模块函数（SDK/模型缓存）：
    - `_get_main_app() -> Optional[module]`
    - `_get_cached_model_from_main(model_path: str) -> Any`
    - `_cache_model_to_main(model_path: str, model: Any) -> None`
    - `_get_infer_api() -> Any`
  - `class RotatedBBoxModel(BaseModule)`（"model/rotated_bbox"）
    - `__init__(*args, **kwargs)`
    - `process(image_list=None, result_list=None) -> (List[Any], List[Dict])`
      - 支持 `.dvp/.pth`（本地）与 `.dvt/.dvo`（SDK）两路径；统一输出带 `origin_index/transform` 的 `local` 条目。
  - `class DetModel(BaseModule)`（"model/det"）: 同上，轴对齐/旋转框检测，`threshold/top_k/return_polygon/epsilon`。
  - `class InstanceSegModel(BaseModule)`（"model/instance_seg"）: 实例分割，保留/推导 `mask_array/bbox`。
  - `class SemanticSegModel(BaseModule)`（"model/semantic_seg"）: 语义分割，按类别输出若干 `mask_array` 项。
  - `class ClsModel(BaseModule)`（"model/cls"）: 分类输出，必要时为可视化补充覆盖整图的 rbox bbox。
    - `process` 参数额外使用 `top_k/batch_size`。
  - `class OCRModel(BaseModule)`（"model/ocr"）: 文本识别输出，统一每张图一个 entry，必要时补充整图 rbox bbox。

- `backend/multi_tasks/NewModules/outputs.py`（2 类）
  - `class SaveImage(BaseModule)`（"output/save_image"）
    - `process(image_list=None, result_list=None) -> (List[Any], List[Dict])`
      - 从同序 `result_list` 抽取 `filename`（或回退时间戳），按 `save_path/suffix/format` 落盘，兼容中文路径。
  - `class Preview(BaseModule)`（"output/preview"）
    - `process(image_list=None, result_list=None) -> (List[Any], List[Dict])`（透传）

- `backend/multi_tasks/NewModules/visualize.py`（2 类）
  - `class VisualizeOnOriginal(BaseModule)`（"output/visualize"）
    - `_build_origin_images(images: List[Any]) -> Dict[int, np.ndarray]`
    - `_map_points_to_original(transform: Dict, pts: np.ndarray) -> np.ndarray`
    - `_to_axis_aligned_bbox(transform: Dict, bbox: List[float]) -> List[int]`
    - `_to_rotated_bbox(transform: Dict, bbox: List[float]) -> List[float]`
    - `_draw_fallback(image: np.ndarray, rect_items: List[Dict], rot_items: List[Dict], vis_cfg: Dict) -> np.ndarray`
    - `_draw_text_labels_bgr(image_bgr: np.ndarray, rect_items: List[Dict], rot_items: List[Dict], vis_cfg: Dict) -> np.ndarray`
    - `process(image_list=None, result_list=None) -> (List[Any], List[Dict])`
      - 将局部坐标结果映射回原图绘制（旋转框/文本/阴影/自适应字号等），输出可视化图像序列。
  - `class VisualizeOnLocal(BaseModule)`（"output/visualize_local"）
    - `@staticmethod _serialize_transform(transform: Optional[Dict]) -> Optional[str]`
    - `@staticmethod _draw_fallback(image, rect_items, rot_items, vis_cfg) -> np.ndarray`
    - `process(image_list=None, result_list=None) -> (List[Any], List[Dict])`
      - 在当前图像局部坐标系内绘制，按 `transform/index/origin_index` 匹配对应结果。

- `backend/multi_tasks/NewModules/main_process.py`（3 类 + 4 函数）
  - `@dataclass NodeDef`：`node_id, node_type, title, properties, raw_inputs, raw_outputs`
  - `@dataclass LinkDef`：`link_id, src_node_id, src_out_idx, dst_node_id, dst_in_idx, data_type`
  - `_is_image_port(name: Optional[str], dtype: Optional[str]) -> bool`
  - `_is_result_port(name: Optional[str], dtype: Optional[str]) -> bool`
  - `_route_to_channels(dst_in_idx: int, dst_input_ports: List[Dict]) -> int`（0->image, 1->result）
  - `class GraphExecutor`
    - `__init__(graph: Dict[str, Any], context: Optional[ExecutionContext]=None)`
    - `_parse_graph() -> None`
    - `run() -> Dict[int, Dict[str, List[Any]]]`
      - 入度拓扑、按输出对编号路由（`src_out_idx//2`）、多路输入聚合为对（`dst_in_idx//2`），第0对直接传参，其余对注入 `module.extra_inputs_in`；收集 `module.extra_outputs`（如 `_1` 后缀）为扩展对；支持通过 `context.progress_cb` 发进度事件。
  - `def main_process(graph_or_json: Any, *, context: Optional[ExecutionContext]=None) -> Dict[int, Dict[str, List[Any]]]`

- `backend/multi_tasks/NewModules/nodes_single_flow.py`（聚合导出，无新增类/函数）
- `backend/multi_tasks/NewModules/__init__.py`（导出基础类并导入各模块以触发注册）
- `backend/multi_tasks/NewModules/output.py`（空文件）

### 设计要点与 I/O 一致性
- **统一签名**: 所有模块对外仅暴露 `process(image_list, result_list)`；输入输出均列表化，单值也会包装为列表（`BaseModule._ensure_list`）。
- **图像包装**: 模块普遍将 `np.ndarray` 包装为 `ModuleImage`，携带 `TransformationState` 与 `original_index`。后续裁剪/仿射用 `derive_child` 链式维护“原图->当前图”的映射。
- **结果统一**: 结果以 `type=="local"` 的 entry 列表为主，字段：
  - `sample_results: List[Dict]`（元素可含 `bbox(4/5)/mask_array/category_name/score/metadata`）
  - `index`（当前序列索引）、`origin_index`（原图索引）、`transform`（若为局部图则给出 `TransformationState.to_dict()`）
- **对齐策略**: 模块在匹配图像与结果时优先用 `transform` 的序列化签名匹配；回退到 `index`；再回退到 `origin_index`。
- **多路 I/O**: 执行器把端口命名/类型识别为 image/result 通道，按 `//2` 成对分组；模块可通过 `extra_inputs_in` 读取额外对，通过 `extra_outputs` 输出额外对（如 `image_list_1/result_list_1`）。
- **跨进程/缓存**: 模型模块通过 `backend.app.internal_model_map` 与全局 `infer_api` 复用/共享模型实例，避免重复加载。
- **可视化与坐标系**: 可视化模块使用 `TransformationState` 将局部检测映射回原图进行绘制；滑窗合并模块在原图坐标系下进行 IoU/IOS、旋转框角度线性变换与分割 mask 并集。

- **类数量分布（总计 26）**:
  - `base_module.py`: 6
  - `inputs.py`: 2
  - `features.py`: 3
  - `sliding_window.py`: 1
  - `sliding_merge.py`: 1
  - `models.py`: 6
  - `outputs.py`: 2
  - `visualize.py`: 2
  - `main_process.py`: 3

- **核心调用链**:
  - 前端 JSON -> `GraphExecutor` -> `ModuleRegistry.get(type)` -> 实例化 `BaseModule` 子类 -> `process` -> 产出 `(image_list, result_list)`（及可选 `extra_outputs`） -> 执行器路由到后继节点输入对。

- **关键扩展点**:
  - 新增模块：继承 `BaseModule`（或 `BaseInputModule`），实现 `process`（或 `generate`），用 `@register_module("your/type")` 注册；声明 `default_properties/input_ports/output_ports` 以便前端提示与执行器路由更精准。

- **异常与健壮性**:
  - 所有模块对参数解析/空值处理/类型兼容做了 try/except 宽松保护；执行器捕获节点异常发出失败事件并抛出终止；路径/编码兼容中文（`cv2.imdecode/tofile`）。

- **额外说明**:
  - `nodes_single_flow.py/__init__.py` 负责保证 import 侧效应触发各模块注册，不直接影响运行时逻辑。

### C# 模块化翻译任务进度

- 约定：

* 逐文件翻译与实现；每完成一个文件即更新此清单；遵循 .NET Framework 4.7.2；结果类型复用 `DlcvCsharpApi.Utils.CSharpResult`，模块间中间结果采用 `Newtonsoft.Json.Linq.JObject/JArray` 描述，不重复封装数据类型。
* 项目特有的数据类型可以封装成单独的数据结构，不要用 List<object>，List<JObject>，Tuple<List<object>, List<JObject>> 这类形态。
* 所有图像格式都使用 OpenCV 的 Mat 格式，保持 RGB 格式。推理是 RGB 直接推，读图是 BGR，需要转 RGB，存图也需要从 RGB 转 BGR。
* 你不会做到一半就停止，你会一直做完所有的任务。

- 构建：`DlcvModules` 项目已在 Debug | x64 构建通过；整体 `OpenIVS.sln` 全量构建需补充 HalconDotNet 依赖（当前 `HalconToMatDemo` 缺少 `HalconDotNet`）。

- [已完成] 记忆文件记录模块化翻译任务清单与进度约定（本条）
- [已完成] 基础模块与注册表：`base_module.py` → `Base.cs`
  - `ExecutionContext`
  - `ModuleRegistry`
  - `BaseModule` / `BaseInputModule`
  - `TransformationState` / `ModuleImage`
- [已完成] 输入模块：`inputs.py` → `Inputs.cs`（`InputImage`、`InputFrontendImage`）
- [已完成] 特征模块：`features.py` → `Features.cs`（`ImageGeneration`、`MergeResults`、`ResultFilter`）
- [已完成] 滑窗：`sliding_window.py` → `SlidingWindow.cs`
- [已完成] 滑窗合并：`sliding_merge.py` → `SlidingMerge.cs`
- [已完成] 模型模块：`models.py` → `Models.cs`（`Det/RotBBox/InstanceSeg/SemanticSeg/Cls/OCR`，复用 `DlcvCsharpApi.Model`）
- [已完成] 输出模块：`outputs.py` → `Outputs.cs`（`SaveImage`、`Preview`）
- [已完成] 可视化：`visualize.py` → `Visualize.cs`（原图/局部绘制骨架）
- [已完成] 执行器：`main_process.py` → `MainProcess.cs`（简化顺序执行骨架）

### C# 加载并执行流程 JSON（正确调用方法）

以下示例展示了如何在 C# 侧正确加载前端导出的流程 JSON（根是 JObject，包含 `nodes/links`），并驱动 `DlcvModules.GraphExecutor` 执行：

```csharp
// 1) 读取流程 JSON（根是 JObject）
string jsonText = File.ReadAllText(jsonPath, Encoding.UTF8);
var root = JObject.Parse(jsonText);
var nodesArr = root["nodes"] as JArray;
if (nodesArr == null) throw new InvalidOperationException("流程 JSON 缺少 nodes 字段");

// 2) 转为 List<Dictionary<string, object>> 供执行器消费
var nodes = new List<Dictionary<string, object>>();
foreach (var item in nodesArr)
{
    if (item is JObject jo)
    {
        nodes.Add(JObjectToDictionary(jo)); // 复用现有工具方法
    }
}

// 3) 强制注册所有模块（触发各模块静态构造函数进行注册）
ForceRegisterModules();

// 4) 构造执行上下文，可选设置前端图片路径（给 input/frontend_image 使用）
var context = new DlcvModules.ExecutionContext();
context.Set("frontend_image_path", image_path);

// 5) 执行（内部按节点的 order 字段排序，缺省回退到 id）
var executor = new DlcvModules.GraphExecutor(nodes, context);
var outputs = executor.Run();

// 6) 取最后一个节点的可视化图像与结果
var last = outputs.OrderBy(kv => kv.Key).Last();
var imageList = last.Value["image_list"] as List<DlcvModules.ModuleImage>;
var resultList = last.Value["result_list"] as JArray;
```

注意：
- 前端导出的 JSON 根对象是 JObject，不是 JArray；必须先 `JObject.Parse` 再取 `nodes`。
- 当前 C# 执行器为线性简化版本：按 `order`（或 `id`）顺序逐节点执行，适合单链路/演示流程；复杂分支/多路端口会在增强版本中实现。

### 近期变更

- 持久化流程并支持更换图片后自动重跑（`DlcvDemo/Form1.cs`）：
  - 加入字段 `loadedFlowNodes`，在加载流程 JSON 后保存节点列表。
  - 新增 `RunLoadedFlow()`，根据当前 `image_path/device_id/rpc_mode` 构造 `ExecutionContext` 并执行，结果自动更新到 `imagePanel1` 与 `richTextBox1`。
  - 在 `button_openimage_Click` 中，如果已加载流程，则选择新图片后自动调用 `RunLoadedFlow()`，无需重新选流程。

- 统一错误输出（`DlcvDemo/Form1.cs`）：
  - 新增 `ReportError(title, ex)`，将完整异常（含堆栈）写入 `richTextBox1`，并以 `MessageBox` 简要提示。
  - `button_load_flow_model_Click`、`button_infer_Click`、`RunLoadedFlow()` 等处均改为调用 `ReportError`。